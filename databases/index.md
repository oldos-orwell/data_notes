Индекс базы данных - это структура данных, которая повышает скорость операций поиска данных в таблице базы данных за счет дополнительных операций записи и дискового пространства для поддержания структуры данных индекса. Индексы используются для быстрого поиска данных без необходимости поиска по каждой строке в таблице базы данных при каждом обращении к указанной таблице. Индексы могут быть созданы с использованием одного или нескольких столбцов таблицы базы данных. 

**Fill Factror** (коэффициент заполнения индекса) определяет количество пространства на странице для хранения индекса на нижнем уровне (уровень листьев). Fill factor используется только при перестройке и создании индекса — т.е. при ребилде страницы будут заполнены на 90%. Это делается специально, чтобы при росте индекса (при вставке в таблицу) на каждой странице оставалось свободное место для вставки значений, дабы избежать необходимости разделения страниц. При вставке новых строк страницы всегда заполняются до 100%.
  
Существуют два типа индексов: кластеризованный и некластеризованный индексы
  
**Кучи** (heap) – это данные, хранящиеся без какой-либо определенной сортировки, не имеющие кластеризованного индекса, доступ и поиск по таким данным происходит последовательно при сканировании страниц, и может занимать довольно долгое время влияя негативно на производительность. В общем, куча позволяет производить вставку данных относительно безболезненно и не будет накладных расходов на хранение и обслуживание, как это бывает в случае кластеризованного индекса. В PostgreSQL все таблицы представляют собой кучу.
  
Индексы могут быть реализованы с использованием различных структур данных, основные: 
* Hash - как-правило используются только как некластеризованные. Используется там, где нужен поиск по ключу.
* Sequential Index - структуры, основанные на упорядоченном хранении (деревья - сбалансированные, B+ и др). Мб кластеризованными и некластеризованными. B-tree индексы покрывают 90% задач.
  
В деревьях индексов есть уровни:
* root level (корневой уровень) - главная точка входа для запросов, пытающихся получить данные через индекс. Содержит указатель на узел из intermediate level
* intermediate levels (промедуточный уровень) - содержит один или более уровней промежуточных узлов, узлы содержат указатель на узел из intermediate или leaf levels
* leaf level (уровень листьев) - конечные узлы, содержащие данные (один уровень). Если это кластеризованный индекс, то на листе узла содержится данные строки, ассоциированной с ключом. Если же это некластеризованный индекс, то лист индекса содержит указатель на кластеризованную таблицу или конкретную строку в куче (если не создан кластеризованный индекс).

## Кластеризованный индекс
Хранит в своих узлах-листьях реальные строки данных. Кластеризация изменяет блок данных в определенном порядке, чтобы соответствовать индексу, в результате чего данные строк хранятся по порядку. Следовательно, для данной таблицы базы данных может быть создан только один кластеризованный индекс.  

Преимуществом является ускорение производительности запросов, в которых поле индекса использкется в where, join, order by.  
Недостатком является то, что доступ к таблице всегда происходит через индекс, что приводит к дополнительной нагрузке. Также при любых DML операциях модифицируются данные не только таблицы но и индекса.  
  
## Некластеризованный индекс
Данные представлены в произвольном порядке, но логический порядок задается индексом. Строки данных могут быть распределены по всей таблице независимо от значения индексируемого столбца или выражения. Некластеризованное дерево индексов содержит ключи индекса в отсортированном порядке, причем конечный уровень индекса содержит только те столбцы (ключевые), по которым определен данный индекс, а также указатель на строки с реальными данными в таблице (строка в куче или кластеризованный индекс, если он задан для таблицы).

Физический порядок строк не совпадает с порядком индекса.
В таблице базы данных может быть более одного некластеризованного индекса.
Преимущества и Недостатки аналогичны класторизованному индексу, но наклвдные расходы при выполнении операторов DML меньше, а поиск менее эффективен из-за необходимости на уровне листьев переходить по ссылке на данные.
    
    
В дополнение к тому, что индекс может быть либо кластеризованным, либо некластеризованным, возможно его дополнительно сконфигурировать:
* Составной индекс - может содержать более одного столбца
* Уникальный индекс - обеспечивает уникальность каждого значения в индексируемом столбце. Уникальный индекс может автоматически создаваться, когда определяют ограничения столбца: первичный ключ (создается кластеризованный индекс) или ограничение на уникальность значений (создается некластеризованный индекс).
* Покрывающий индекс - позволяет конкретному запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к записям самой таблицы за счет хранения значений части столбцоы в индексе.
* Фильтруемый индекс - некластеризованный индекс только для определенного подмножества данных ключевого столбца
* Полнотекстовый индекс - используется для полнотестового поиска по столбцу индекса. Они отличаются от стандартных индексов тем, что вместо использования всего столбца в качестве ключа индекса, данные в столбце разбиваются на токены, и именно эти токены используются для построения индекса и служат в качестве предиката при навигации по структуре индекса. Сама структура индекса также сохраняется в своем собственном каталоге, а не в файлах данных базы данных.
  
  
Рекомендации при планировании стратегии индексирования:
* Для таблиц которые часто обновляются используйте как можно меньше индексов, т.к. при вставке / обновлении данных обновляется и индекс - количество операций собственно вставки увеличивается на количество индексов.
* Если таблица содержит большое количество данных, но их изменения незначительны, тогда используйте столько индексов, сколько необходимо для улучшение производительности ваших запросов.
* Для кластеризованных индексов старайтесь использовать настолько короткие поля насколько это возможно. Наилучшим образом будет применение кластеризованного индекса на столбцах с уникальными значениями и не позволяющими использовать NULL. Вот почему первичный ключ часто используется как кластеризованный индекс.
* Уникальность значений в столбце влияет на производительность индекса. В общем случае, чем больше у вас дубликатов в столбце, тем хуже работает индекс. С другой стороны, чем больше уникальных значения, тем выше работоспособность индекса. Когда возможно используйте уникальный индекс.
* Для составного индекса возьмите во внимание порядок столбцов в индексе. Столбцы, которые используются в выражениях WHERE (к примеру, WHERE FirstName = 'Charlie') должны быть в индексе первыми. Последующие столбцы должны быть перечислены с учетом уникальности их значений (столбцы с самым высоким количеством уникальных значений идут первыми).


___
[14 вопросов об индексах в SQL Server, которые вы стеснялись задать / Хабр](https://habr.com/ru/articles/247373/)  
[Database index - Wikipedia](https://translated.turbopages.org/proxy_u/en-ru.ru.9786bacf-6548dee2-eb61998f-74722d776562/https/en.wikipedia.org/wiki/Database_index)  
[T-SQL Кучи, кластеризованные индексы и некластеризованные индексы](http://snakeproject.ru/rubric/article.php?art=tsql_indexes)  
[Переоткрывая хэш-индексы в PostgreSQL / Habr](https://habr.com/ru/amp/publications/747910/)  
  
[Введение в B-Tree и хэш-индексы в PostgreSQL | SQL-Ex blog](https://sql-ex.ru/blogs/?%2FVvedenie_v_B-Tree_i_hjesh-indeksy_v_PostgreSQL.html=)  
[Типы индексов SQL Server | SQL-Ex blog](https://sql-ex.ru/blogs/?%2FTipy_indeksov_SQL_Server.html=)  
[Полнотекстовый поиск и его возможности / Хабр](https://habr.com/ru/articles/40218/)  
[Об индексах и о том какие индексы нужны для запросов  ](http://kurenkov.pro/blog/86-ob-indeksakh-i-o-tom-kakie-indeksy-nuzhny-dlya-zaprosov)  
